#!/bin/bash

#
# dotfiles
#
# Command-line interface for managing dotfiles.
#

readonly DOTFILES="${DOTFILES:=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)}"
readonly VERSION='0.1.0'

# Determines whether we are in verbose mode
VERBOSE=0

# List all subcommands and their descriptions
declare -A subcommands
subcommands['install [ -v|--verbose]']='Install dotfiles packages.'
subcommands['list']='List all available packages.'
subcommands['new NAME [-v|--verbose]']='Create a new package NAME in the current dir.'
subcommands['reload']='Reload shell configuration from disk.'
subcommands['remove [-v|--verbose]']='Remove dotfiles packages.'
subcommands['update [-v|--verbose]']='Fetch the latest dotfiles from GitHub.'

# Load the dotfiles helper functions library
for lib in ${DOTFILES}/lib/*; do
  source ${lib}
done

show_help() {
  echo 'dotfiles - Command-line interface for managing dotfiles'
  echo
  echo 'Usage:'

  for name in "${!subcommands[@]}"; do
    local desc="${subcommands[${name}]}"
    printf '  dotfiles %-24s %s\n' "${name}" "${desc}"
  done | sort -k 2

  echo
  echo 'Options:'
  echo '  -h --help     Show this screen.'
  echo '  -V --version  Show version.'

  return 0
}

show_version() {
  echo "dotfiles ${VERSION}"
  return 0
}

dotfiles_install() {
  header "Begin installing dotfiles..."
  sudo -v || return 1
  packages_install
  local err="$?"

  header 'Dotfiles installation complete.'
  echo '=> Existing dotfiles were backed up in ~/.dotfiles_old/'

  return ${err}
}

dotfiles_list() {
  echo 'Available packages:'
  packages_list
  return 0
}

dotfiles_new() {
  local name="$1"

  if [[ -z ${name} ]]; then
    echo "error: no name specified" 1>&2
    echo "usage: dotfiles new <name>" 1>&2
    return 1
  fi

  local pkg_dir="${PWD}/${name}"
  debug "pkg_dir=${pkg_dir}"

  mkdir -p "${pkg_dir}/files"
  touch "${pkg_dir}/files/.gitkeep"

  local package="#!/bin/bash\n\n"
  package+="DESCRIPTION='Does something cool.\"\n"
  package+="INSTALL_MSG='Installing package...'\n"
  package+="UNINSTALL_MSG='Uninstalling package...'\n\n"
  package+="install() {\n"
  package+="  return\n"
  package+="}\n\n"
  package+="uninstall() {\n"
  package+="  return \n"
  package+="}\n"
  printf "${package}" > "${pkg_dir}/package"

  local gitignore="#\n"
  gitignore+="# .gitignore\n#\n"
  gitignore+="#\n# Exclude certain package files from being pulled into Git\n"
  gitignore+="#\n"
  printf "${gitignore}" > "${pkg_dir}/.gitignore"

  return 0
}

dotfiles_reload() {
  source ~/.bashrc
  return $?
}

dotfiles_remove() {
  header 'Begin uninstalling dotfiles...'
  sudo -v || return 1
  packages_uninstall
  local err="$?"

  header 'Dotfiles deinstallation complete.'
  echo '=> Backup dotfiles were restored from ~/.dotfiles_old/'

  return ${err}
}

dotfiles_update() {
  packages_pre_update

  # Stash any local uncommitted changes and pull upstream updates
  header 'Pulling upstream updates...'
  git -C "${DOTFILES}" stash --quiet
  git -C "${DOTFILES}" pull

  # Restore any local uncommitted changes
  if execute_silent git -C "${DOTFILES}" stash show -u; then
    echo 'Preserved uncommitted changes.'
    git -C "${DOTFILES}" stash pop --quiet
  fi

  # Install the new packages
  header 'Reinstalling dotfiles...'
  sudo -v || return 1
  packages_install

  packages_post_update
  header 'Update complete.'

  return 0
}

# Ensure we exit the script when user hits CTRL+C (SIGINT)
trap 'exit' INT

# Parse long options
for arg in "$@"; do
  shift
  case ${arg} in
    --help | help)
      set -- "$@" '-h'
      ;;
    --version | version)
      set -- "$@" '-V'
      ;;
    --verbose)
      set -- "$@" '-v'
      ;;
    --*)
      echo "error: invalid option: ${arg}" 1>&2
      exit 1
      ;;
    *)
      set -- "$@" "${arg}"
      ;;
  esac
done

# Parse short options
OPTIND=1
while getopts ':hVv' opt; do
  case ${opt} in
    h)
      show_help
      exit 0
      ;;
    V)
      show_version
      exit 0
      ;;
    v)
      VERBOSE=1
      ;;
    \?)
      echo "error: invalid option: -${OPTARG}" 1>&2
      exit 1
      ;;
  esac
done
shift "$((OPTIND - 1))"

# Parse subcommands
subcommand="$1"; shift
case ${subcommand} in
  install)
    while getopts ':v' opt; do
      case ${opt} in
        v)
          VERBOSE=1
          ;;
        \?)
          echo "error: invalid option: -${OPTARG}" 1>&2
          exit 1
          ;;
      esac
    done
    dotfiles_install
    exit $?
    ;;
  list)
    dotfiles_list
    exit $?
    ;;
  new)
    dotfiles_new $1
    exit $?
    ;;
  reload)
    dotfiles_reload
    exit $?
    ;;
  remove)
    while getopts ':v' opt; do
      case ${opt} in
        v)
          VERBOSE=1
          ;;
        \?)
          echo "error: invalid option: -${OPTARG}" 1>&2
          exit 1
          ;;
      esac
    done
    dotfiles_remove
    exit $?
    ;;
  update)
    while getopts ':v' opt; do
      case ${opt} in
        v)
          VERBOSE=1
          ;;
        \?)
          echo "error: invalid option: -${OPTARG}" 1>&2
          exit 1
          ;;
      esac
    done
    dotfiles_update
    exit $?
    ;;
  *)
    if [[ -z ${subcommand} ]]; then
      echo 'error: no command or flags specified'
      echo 'Try "dotfiles --help" for more information.'
    else
      echo "error: invalid subcommand: ${subcommand}"
    fi
    exit 1
    ;;
esac
